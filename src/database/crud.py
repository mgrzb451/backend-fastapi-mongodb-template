from .models import StudentIn, StudentUpdate
from bson import ObjectId
from fastapi import HTTPException
from pymongo import ReturnDocument

class CRUD:
  """
  All the methods here will use FastAPI Dependency injection mechanism to access the students collection stored under the `collection` variable. The dependency is injected in the router module into the parameter we called "collection" in the methods below
  """
  @staticmethod
  async def add_student(request:StudentIn, collection):
    # the request with the student data comes from the frontend in a form of a Pydantic model. To get the json inside we use the model_dump() method that returns a dictionary
    student_data = request.model_dump()
    # the insert_one() method returns an InsertOneResult object that has the id assigned by mongo stored in it. We can use that to return a complete document (with the id) to the front end
    result = await collection.insert_one(student_data)
    # since we already have the "_id" from mongo we can just add it to the student_data dict that we got from the frontend and we have a complete document
    student_data["_id"] = result.inserted_id
    # This saves us performing another database query â¬‡ to get the full document
    # new_student = await collection.find_one({"_id": result.inserted_id})
    return student_data
  
  @staticmethod
  async def get_all_students(collection):
    # .find() by itself returns an AsyncCursor (an iterator?) we use to_list() to get a normal list
    return await collection.find().to_list()

  @staticmethod
  async def get_student(id:str, collection):
    # find_one() will return None if no matches we can use that to raise an Exception
    student = await collection.find_one({"_id": ObjectId(id)})
    if not student:
      raise HTTPException(status_code=404, detail=("Student not found"))
    else:
      return student
  
  @staticmethod
  async def update_student(id:str, request:StudentUpdate, collection):
    """
    Both find_one_and_update() and update_one() first have to search the collection then perform the update. The difference is that find_one_and_update() returns None if no document found and then either the old document or the updated one and update_one() just returns an object with update status.
    find_one_and_update() also has extra functionality like only returning specific fields, sorting returned documents if there are several, adding new fields if they're not present
    """
    new_data = {}
    # we  use the exclude_unset=True argument to not include the filed that have no values in the dictionary generated by .model_dump(). This way there'll be fewer key: value pairs to iterate over
    for key, value in request.model_dump(exclude_unset=True).items():
      if value:
        new_data[key] = value
    # we use  ReturnDocument.AFTER option to tell find_one_and_update() to return the updated student. By default it returns the old one. Kinda dumb
    updated_student = await collection.find_one_and_update(filter={"_id": ObjectId(id)}, update={"$set": new_data}, return_document=ReturnDocument.AFTER)
    if not updated_student:
      raise HTTPException(status_code=404, detail=("No student with specified ID"))
    else:
      return updated_student
    
    """
    # update_one() status responses:
    response on correct update:
    UpdateResult({'n': 1, 'electionId': ObjectId('7fffffff00000000000002f6'), 'opTime': {'ts': Timestamp(1753761513, 7), 't': 758}, 'nModified': 1, 'ok': 1.0, '$clusterTime': {'clusterTime': Timestamp(1753761513, 7), 'signature': {'hash': b'\x17\xa5\xee6\xe4\xd1F\xb2\xe9\xe7\x0b\xea\x9c\xf2\xa6AN\xbb\xa2>', 'keyId': 7494700244844675110}}, 'operationTime': Timestamp(1753761513, 7), 'updatedExisting': True}, acknowledged=True)

    response when no document with matching id:
    UpdateResult({'n': 0, 'electionId': ObjectId('7fffffff00000000000002f6'), 'opTime': {'ts': Timestamp(1753761787, 44), 't': 758}, 'nModified': 0, 'ok': 1.0, '$clusterTime': {'clusterTime': Timestamp(1753761787, 44), 'signature': {'hash': b'R\xc6\x11\x19\x91\x8a\xfe!F\x89g\xa1nM"\xe9\xa2\xb37q', 'keyId': 7494700244844675110}}, 'operationTime': Timestamp(1753761787, 44), 'updatedExisting': False}, acknowledged=True)
    """

  @staticmethod
  async def delete_student(id:str, collection)->None:
    """
    delete_one() and find_one_and_delete() work similarly to updates. find_one_and_delete() returns the deleted document and delete_one() returns a DeleteResult. In this function we use the plain delete_one() since we don't want to return the student
    """
    result = await collection.delete_one(filter={"_id": ObjectId(id)})
    """
    successful DeleteResult:
    DeleteResult({'n': 1, 'electionId': ObjectId('7fffffff00000000000002f6'), 'opTime': {'ts': Timestamp(1753790581, 126), 't': 758}, 'ok': 1.0, '$clusterTime': {'clusterTime': Timestamp(1753790581, 126), 'signature': {'hash': b'\xe5\x16\x1f\xd9\xfd\xb8\xc2\xc5K\xfb\xdb\xaca\x8ck\xb4\xc7\xa3\xf0\x84', 'keyId': 7494700244844675110}}, 'operationTime': Timestamp(1753790581, 126)}, acknowledged=True)

    failed DeleteResult:
    DeleteResult({'n': 0, 'electionId': ObjectId('7fffffff00000000000002f6'), 'opTime': {'ts': Timestamp(1753790632, 43), 't': 758}, 'ok': 1.0, '$clusterTime': {'clusterTime': Timestamp(1753790632, 43), 'signature': {'hash': b'VZ\xf7\xd5#\xea\xe9\xd3_\x86FsNg\x83\x87{\xd7\x9a\x99', 'keyId': 7494700244844675110}}, 'operationTime': Timestamp(1753790632, 43)}, acknowledged=True)
    """
    # Let's use the 'n' attribute to determine if the user-passed id was found in the database
    # the 'n' attribute is accessed through the deleted_count property and it's an int
    if result.deleted_count == 0:
      raise HTTPException(status_code=404, detail=(f"Student with id: {id} not found in records"))

students_crud = CRUD()


